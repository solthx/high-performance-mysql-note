## 基准测试
### 1. mysqlslap 
- 常用参数说明
    - `--auto-generate-sql` 由系统自动生成sql脚本进行测试
    - `--auto-generate-sql-add-autoincrement` 在生成的表中增加自增ID （Innodb里需要用）
    - `--auto-generate-sql-load-type` 指定测试中使用的查询类型（例如读、写...）
    - `--auto-generate-sql-write-number` 指定初始化数据时生成的数据量
    - `--concurrency` 指并发线程的数量
    - `--engine` 指定测试表的存储引擎，可以用逗号分割多个存储引擎（）
    - `--no-drop` 指定不清理测试数据； 不能和上面的多个存储引擎一起使用，因为上面的多个引擎的测试，是测试完一个就把数据删除了；
    - `--iterations` 指定测试运行的次数; 同样的，因为每次都生成新的数据，所以使用这个数据的时候，就不可以使用上面这个数据；
    - `--number-of-queries` 指定每一个线程执行的查询数量；
    - `--debug-info` 指定输出额外的内存及CPU统计信息
    - `--number-int-cols` 指定测试表中包含的INT类型列的数量
    - `--number-char-cols` 指定测试表中包含的varchar类型列的数量
    - `--create-schema` 指定了用于执行测试的数据库名字
    - `--query` 用于指定自定义的sql脚本
    - `--only-print` 并不会运行测试脚本，而是把生成的脚本打印出来

### 2. sysbench
可以对io, cpu, 内存等等进行测试.. 很全面且灵活，比较常用，适合对服务器进行测试。
1. 常用参数
    - `--test` 用于指定所要执行的测试类型，支持以下参数
        - `fileio` 文件系统IO性能测试
        - `cpu` CPU性能测试
        - `memory` 内存性能测试
        - `Oltp` 测试要指定具体的lua脚本
        Lua脚本位于 `sysbench-0.5/sysbench/tests/db`
    - `--mysql-db` 用于指定执行基准测试的数据库名
    - `--mysql-table-engine` 用于指定所使用的存储引擎
    - `--oltp-tables-count` 执行测试的表的数量
    - `--oltp-table-size` 指定每个表中的数据行数
    - `--num-threads` 指定测试的并发线程数量
    - `--max-time` 指定最大的测试时间
    - `--report-interval` 指定间隔多久输出依次统计信息
    - `--mysql-user` 指定执行测试的MYSQL用户
    - `--mysql-password` 指定执行测试的MYSQL用户的密码
    - `prepare` 用于准备测试数据 
    - `run` 用于实际进行测试
    - `cleanup` 用于清理测试数据

2. 测试举例:
   - 基础组件的测试:
     - 测试cpu性能: 计算小于10000的素数:  <br>``sysbench --test=cpu --cpu-max-prime=10000 run``
     - 测试io性能:
        - 随机读写: `sysbench --test=fileio --num-threads=8 --init-rng=on --file-total-size=1G --file-test-mode=rndrw  run `
        - 生成一个G的文件：`sysbench --test=fileio --file-total-size=1G prepare`
    - 数据库性能测试:
        1. 新建一个数据库 `create database imooc;`
        2. 设置权限 `grant all privileges on *.* to sbest@'localhost' identified by '123456';`
        3. 准备测试数据(表和表中的数据)   
            - 插入10个表，每个表10000行记录，使用innodb引擎，使用的脚本是`sysbench/tests/db/`下面的脚本
            - `sysbench --test=./oltp.lua --mysql-table-engine=innodb --oltp-table-size=10000 --mysql-db=imooc --mysql-user=sbest --mysql-password=123456 --oltp-tables-count=10 prepare`
        4. 保存一下当前的系统状态(运行前的系统状态), 运行脚本
        5. 开始测试 `sysbench --test=./oltp.lua --mysql-table-engine=innodb --oltp-table-size=10000 --mysql-db=imooc --mysql-user=sbest --mysql-password=123456 --oltp-tables-count=10 run` <br>最后一个改成了`run`
        6. 数据结果分析.
   
ps： 使用的sysbench版本为0.5；需要注意的是0.4的版本有一些指令不能用.. 比如`--test=oltp.lua` 就会无法识别.. 


## 数据库结构优化
### 1. 数据库结构优化的目的
1. 减少数据冗余
    - 相同的数据在多个地方存在，或者某一列可以由其他列计算得到
    - 并不是消除，而是减少。
2. 尽量避免数据维护中出现更新，插入和删除异常
    - 插入异常:
        - 因为表的设计问题，导致插入失败。
    - 更新异常:
        - 更改表中的某个实体的单独属性时， 对多行进行了更新（想更新一条数据,结果工作量大,还容易出错）
    - 删除异常：
        - 删除表中某一实体，怎么会导致其他实体的消失。

3. 节约数据库的存储空间
4. 提高查询效率

### 2. 数据库结构设计的步骤

1. 需求分析( 全面了解产品设计的存储需求 ):
    1. 存储需求
    2. 数据处理需求
    3. 数据的安全性和完整性

2. 逻辑设计( 设计数据的逻辑存储结构 ):
    - 数据实体之间的逻辑关系，解决数据冗余和数据维护异常

3. 物理设计:
    - 根据所使用的数据库特点进行表结构设计

### 3. 数据库设计范式

1. 第一范式:
    1. 属性不可分
    2. 由基本数据类型构成
    3. 是个二维表

2. 第二范式(当前主键在决定每一个属性的时候，都是最小主键):
   1. 满足第一范式
   2. 不存在 非主键列 对 主键子集存在函数依赖:
        - 举个例子:  现在有一个SC( 学号，课程号，学生姓名，课程名称 )， 其中主键是 ( 学号，课程号 )， 但是学生姓名这个属性只依赖于学号，课程名称只依赖于课程号

3. 第三范式( 每个属性都唯一依赖于主键 ):
   1. 满足第二范式
   2. 每一个非主属性既不部分依赖于，也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖。 
        - 举个例子: 现在有一个SD( 学号，学生姓名，学院名称，学院地址 ) ，学号是主键，他满足了第二范式，但学院地址同时也依赖于学院名称， 学院名称依赖于学号，因此，学院地址传递依赖于学号，这就不满足了第三范式。 

范式化的设计往往会带来查询效率低下的问题( 因为要把一张表拆分成多个表，查询的时候在做连接时，就要访问多个表 )， 因此在某些业务场景中，为了提高查询效率，需要做一些反范式化的设计。 

### 4. 范式化和反范式化的选择

1. 范式化设计的优缺点:
    1. 优点:
       - 可以尽量减少数据冗余
       - 范式化的更新操作比反范式化更快 (写操作比较快)
       - 范式化的表通常比反范式化小     
    2. 缺点:
       - 对于查询操作， 需要对多个表进行关联 (读操作比较慢)
       - 更难进行索引优化

2. 反范式化的优缺点:
    1. 优点:
        - 可以减少表的关联 ( 减少了全表扫描 )
        - 可以更好的进行索引优化
    2. 缺点:
        - 可能会存在数据冗余及维护异常
        - 对数据的修改需要更多的成本， 一次修改需要修改多个地方。

因此，要结合的使用范式化和反范式化设计.

3. 逻辑设计的个人小结:
    1. 先需求分析，列出系统需要实现的功能
    2. 根据每一个功能抽象出实体和实体间的联系 ( E-R图 )
    3. 根据E-R图来设计表, 严格满足第三范式
    4. 根据具体场景来对表进行调整， 对某些表进行反范式化调整。